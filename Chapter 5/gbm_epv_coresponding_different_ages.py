# -*- coding: utf-8 -*-
"""GBM_EPV_CORESPONDING_DIFFERENT_AGES.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TRiF5LXRmHdXS-kGrp4pqCS0pI1XcfAn
"""

import numpy as np
import pandas as pd
from scipy.stats import norm
import matplotlib.pyplot as plt

# Parameters
mu = 0.07           # Expected return
sigma = 0.20        # Volatility
gamma = 3           # Risk aversion
r = 0.02            # Interest rate
g = 0.01            # Guaranteed annuity rate
x = 65              # Starting age
y = 100             # Max age
m = 10000           # Number of simulations

# Load S&P 500 data (assumed already in Python environment)
# You should replace this with your actual DataFrame
# For illustration, here is a dummy monthly return series:
np.random.seed(123)
monthly_returns = np.random.normal(loc=mu/12, scale=sigma/np.sqrt(12), size=(y-x)*12)

# Generate GBM paths
def simulate_gbm(mu, sigma, T, m, x0=1):
    dt = 1/12
    n = int(T / dt)
    Z = np.random.normal(size=(m, n))
    W = np.cumsum(np.sqrt(dt) * Z, axis=1)
    t = np.linspace(dt, T, n)
    drift = (mu - 0.5 * sigma**2) * t
    diffusion = sigma * W
    S = x0 * np.exp(drift + diffusion)
    return np.column_stack((np.full(m, x0), S))

T = y - x
gbm_paths = simulate_gbm(mu, sigma, T, m)

# Load mortality data
# Assuming a CSV like 'table2001.csv' with columns: Age, qx
# Replace 'qx' with your actual column name if different
qx_data = pd.read_csv('table2001.csv')
qx_data['px'] = 1 - qx_data['qx']
qx_data['px_lag'] = qx_data['px'].shift(1).fillna(1)
qx_data['lx'] = qx_data['px_lag'].cumprod()

# Create a dictionary for px and lx
px_dict = dict(zip(qx_data['Age'], qx_data['px']))
lx_dict = dict(zip(qx_data['Age'], qx_data['lx']))

# Actuarial Present Value: a_x (continuous whole life annuity)
def ax(age, r, g):
    n = int((y - age) * 12)
    discount = [(1 / (1 + g)) ** (t / 12) for t in range(1, n + 1)]
    survival = [lx_dict.get(age + t // 12, 0) / lx_dict[age] for t in range(1, n + 1)]
    return sum(d * s for d, s in zip(discount, survival)) / 12

# Present value of term insurance over [0, n)
def Ax(age, r, g):
    n = int((y - age) * 12)
    discount = [(1 / (1 + g)) ** (t / 12) for t in range(1, n + 1)]
    qxs = [qx_data[qx_data['Age'] == (age + t // 12)]['qx'].values[0] for t in range(1, n + 1)]
    pxs = [lx_dict.get(age + t // 12, 0) / lx_dict[age] for t in range(1, n + 1)]
    return sum(d * px * qx for d, px, qx in zip(discount, pxs, qxs)) / 12

# Utility functions
def CRRA(w, gamma):
    if gamma == 1:
        return np.log(w)
    else:
        return (w ** (1 - gamma)) / (1 - gamma)

# Simulation loop
annuity_factors = ax(x, r, g)
term_factors = Ax(x, r, g)
retirement_values = gbm_paths[:, -1]  # Terminal wealth

# Scenario 1: Without guarantee
utilities_no_guarantee = CRRA(retirement_values / annuity_factors, gamma)

# Scenario 2: With guaranteed annuity option
term_ins_value = np.exp(-r * (y - x)) * term_factors
utilities_guarantee = CRRA(retirement_values / annuity_factors, gamma) * np.exp(-gamma * term_ins_value)

# Expected utilities
EU_no_guarantee = np.mean(utilities_no_guarantee)
EU_guarantee = np.mean(utilities_guarantee)

# Certainty Equivalents
CE_no_guarantee = (EU_no_guarantee * (1 - gamma)) ** (1 / (1 - gamma))
CE_guarantee = (EU_guarantee * (1 - gamma)) ** (1 / (1 - gamma))

# Output results
print("Expected Utility without guarantee:", EU_no_guarantee)
print("Expected Utility with guarantee:   ", EU_guarantee)
print("Certainty Equivalent without guarantee:", CE_no_guarantee)
print("Certainty Equivalent with guarantee:   ", CE_guarantee)

# Optional: Plot sample GBM paths
plt.figure(figsize=(10, 5))
for i in range(10):
    plt.plot(gbm_paths[i], alpha=0.5)
plt.title('Sample GBM Paths of S&P 500')
plt.xlabel('Months')
plt.ylabel('Simulated Value')
plt.grid(True)
plt.show()
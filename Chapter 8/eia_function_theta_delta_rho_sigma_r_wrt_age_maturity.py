# -*- coding: utf-8 -*-
"""EIA_function_theta_delta_rho_sigma_r_wrt_age_maturity.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yL8KWUEGf8dntUy4G42527xpYlPhj9ir
"""

import numpy as np
import pandas as pd
from scipy.stats import norm
from scipy.optimize import root_scalar
import matplotlib.pyplot as plt

# Default constants
a = 0.85837
b = 0.089102
lambda0 = 0.25
lambda_inf = lambda0
S0 = 1
gamma = 0.2
g = 0.03
r0 = 0.05

def simulate_hawkes(lambda0, theta, delta, T):
    t = 0
    times = []
    intensity = lambda0
    while t < T:
        u = np.random.uniform()
        w = -np.log(u) / intensity
        t += w
        if t >= T:
            break
        d = np.random.uniform()
        current_lambda = lambda0 + np.sum(theta * np.exp(-delta * (t - np.array(times))))
        if d <= current_lambda / intensity:
            times.append(t)
            intensity = current_lambda + theta
        else:
            intensity = current_lambda
    return times

def CPP_t(tm, alpha, T, sigma_r, sigma_s, rho1, theta1, delta1):
    sigma1 = sigma_s
    sigma2 = sigma_r
    rho = rho1
    theta = theta1
    delta = delta1
    m_tilde = 0.05
    sigma = 0.03
    m = np.exp(m_tilde + sigma**2 / 2) - 1
    simulations = 100000

    t = tm
    E = 0

    M1_0 = 1 - np.exp(-a * (t - 0))
    M2_0 = (1 - np.exp(-a * (t - 0))) ** 2
    integral_M1 = t - 1 / a + np.exp(-a * t) / a
    integral_M2 = t + 1 / (2 * a) - 2 / a - np.exp(-2 * a * t) / (2 * a) + 2 * np.exp(-a * t) / a
    integral_M1T = t - np.exp(-a * (T - t)) / a + np.exp(-a * T) / a
    integral_M1tM1T = t - 1 / a + np.exp(-a * t) / a - np.exp(-a * (T - t)) / a + \
                      np.exp(-a * T) / a + np.exp(-a * (T - t)) / (2 * a) - \
                      np.exp(-a * (T + t)) / (2 * a)

    for _ in range(simulations):
        TJ = simulate_hawkes(lambda0, theta, delta, t)
        n = len(TJ)

        integral_lambda = lambda_inf * t + (lambda0 - lambda_inf) * (1 - np.exp(-delta * t)) / delta
        if n != 0:
            for tj in TJ:
                integral_lambda += theta * (1 - np.exp(-delta * (t - tj))) / delta

        lambda_big = b * t + (r0 - b) * M1_0 / a - sigma1 * sigma2 * rho * integral_M1T / a - \
                     sigma2 ** 2 * integral_M1tM1T / a ** 2 - sigma1 ** 2 * t / 2 - integral_lambda * m

        M_T_r = np.log(S0) + lambda_big
        if n != 0:
            M_T_r += m_tilde * n

        V_T_r = sigma1 ** 2 * T + (sigma2 ** 2 / a ** 2) * integral_M2 + \
                2 * rho * sigma1 * sigma2 / a * integral_M1
        if n != 0:
            V_T_r += sigma ** 2 * n

        sqrt_V = np.sqrt(V_T_r)
        a1 = norm.cdf((g * t / alpha - M_T_r + np.log(S0)) / sqrt_V)
        a2 = norm.cdf((gamma * t / alpha - M_T_r + np.log(S0) - alpha * V_T_r) / sqrt_V)
        a3 = norm.cdf((g * t / alpha - M_T_r + np.log(S0) - alpha * V_T_r) / sqrt_V)
        a4 = norm.cdf(-(gamma * t / alpha - M_T_r + np.log(S0)) / sqrt_V)

        E_T = np.exp(g * t) * a1 + np.exp(alpha * M_T_r + alpha ** 2 * V_T_r / 2 - alpha * np.log(S0)) * \
              (a2 - a3) + np.exp(gamma * t) * a4
        E += E_T

    a_t = (b - sigma2 ** 2 / (2 * a ** 2)) * (M1_0 / a - t) - sigma2 ** 2 * M2_0 / (4 * a ** 3)
    b_t = M1_0 / a
    X_T = np.exp(a_t - b_t * r0)

    return E / simulations, X_T

def Ppp(alpha, age, maturity, sigma_r, sigma_s, rho1, theta1, delta1, qx, px):
    x = age
    T = maturity
    tpx = np.cumprod(px[x:110])

    P_pp = 0
    for t in range(1, T + 1):
        cpp1, cpp2 = CPP_t(t, alpha, T, sigma_r, sigma_s, rho1, theta1, delta1)
        if t == 1:
            P_pp += cpp1 * cpp2 * qx[x]
        else:
            P_pp += cpp1 * cpp2 * qx[x + t] * tpx[t - 2]

    cpp1, cpp2 = CPP_t(T, alpha, T, sigma_r, sigma_s, rho1, theta1, delta1)
    value = P_pp + cpp1 * cpp2 * tpx[T - 1] - 1
    return value

def eia_annual(age, maturity, sigma_r, sigma_s, rho1, theta1, delta1, qx, px):
    result = root_scalar(
        lambda alpha: Ppp(alpha, age, maturity, sigma_r, sigma_s, rho1, theta1, delta1, qx, px),
        bracket=[0.001, 1.5],
        method='brentq'
    )
    return result.root

mortality = pd.read_csv("/content/china_mortality_2010_13.csv")  # Adjust path
qx = mortality.iloc[:, 1].values
px = mortality.iloc[:, 2].values

ages = np.arange(40, 72, 2)
theta_vals = [0.5, 1, 1.5]
delta_vals = [1.5, 2, 3]
rho_vals = [-0.1, 0, 0.1]
sigma_r_vals = [0.05, 0.1, 0.15]

X = np.zeros((len(ages), 13))
for i, age_val in enumerate(ages):
    X[i, 0] = age_val
    for j in range(3):
        X[i, j+1] = eia_annual(age_val, 5, 0.1, 0.2, rho_vals[2], theta_vals[j], delta_vals[1], qx, px)
    for j in range(3):
        X[i, j+4] = eia_annual(age_val, 5, 0.1, 0.2, rho_vals[2], theta_vals[1], delta_vals[j], qx, px)
    for j in range(3):
        X[i, j+7] = eia_annual(age_val, 5, 0.1, 0.2, rho_vals[j], theta_vals[1], delta_vals[1], qx, px)
    for j in range(3):
        X[i, j+10] = eia_annual(age_val, 5, sigma_r_vals[j], 0.2, rho_vals[2], theta_vals[1], delta_vals[1], qx, px)

df_X = pd.DataFrame(X)
df_X.to_csv("EIA_function_lambda0_0.25_vs_age.csv", index=False)

times = np.arange(1, 11)
Y = np.zeros((len(times), 13))
for i, t in enumerate(times):
    Y[i, 0] = t
    for j in range(3):
        Y[i, j+1] = eia_annual(50, t, 0.1, 0.2, rho_vals[2], theta_vals[j], delta_vals[1], qx, px)
    for j in range(3):
        Y[i, j+4] = eia_annual(50, t, 0.1, 0.2, rho_vals[2], theta_vals[1], delta_vals[j], qx, px)
    for j in range(3):
        Y[i, j+7] = eia_annual(50, t, 0.1, 0.2, rho_vals[j], theta_vals[1], delta_vals[1], qx, px)
    for j in range(3):
        Y[i, j+10] = eia_annual(50, t, sigma_r_vals[j], 0.2, rho_vals[2], theta_vals[1], delta_vals[1], qx, px)

df_Y = pd.DataFrame(Y)
df_Y.to_csv("EIA_function_lambda0_0.25_vs_maturity.csv", index=False)
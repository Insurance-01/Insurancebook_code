# -*- coding: utf-8 -*-
"""EIA_hawkes_montecarlo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13lgoVU1BIRGI8cx1xiBAEu0c_aFnjkZm
"""

import numpy as np
import pandas as pd
from numpy.random import multivariate_normal, normal, lognormal, uniform
from scipy.optimize import root_scalar

def simulate_hawkes(lambda0, theta, delta, T):
    times = []
    t = 0
    lambda_t = lambda0

    while t < T:
        u = uniform()
        M = lambda_t
        w = -np.log(u) / M
        t += w

        if t >= T:
            break

        d = uniform()
        lambda_star = lambda0 + np.sum([theta * np.exp(-delta * (t - tj)) for tj in times])
        if d <= lambda_star / M:
            times.append(t)
            lambda_t = lambda_star
        else:
            lambda_t = lambda_star
    return np.array(times)

def CPP_t(T1, alpha, lambda0=0.9, theta=1, delta=1.2195, sigma1=0.2,
          a=0.85837, b=0.089102, sigma2=0.05, rho=0.1, m=0.05, sigma=0.03**2, dt=1/252):

    N = 100
    R = []
    E = []

    for j in range(N):
        t1 = int(T1 / dt)
        time = np.cumsum(np.concatenate([[0], np.full(t1, dt)]))
        TJ = simulate_hawkes(lambda0, theta, delta, T1)
        n = len(TJ)

        r = np.zeros(t1 + 1)
        s = np.zeros(t1 + 1)
        l = np.zeros(t1 + 1)
        r[0] = 0.05
        s[0] = 1
        l[0] = lambda0

        Sigma = np.array([[1, rho], [rho, 1]])
        k = 0

        for i in range(t1):
            ex = multivariate_normal([0, 0], Sigma)

            r[i+1] = r[i] + a * (b - r[i]) * dt + sigma2 * np.sqrt(dt) * ex[0]
            l[i+1] = l[i] - delta * l[i] * dt

            if k < n and TJ[k] >= time[i] and TJ[k] <= time[i+1]:
                l[i+1] += theta
                k += 1

            s[i+1] = s[i] * (r[i] * dt + sigma1 * np.sqrt(dt) * ex[1] - l[i] * dt * m) + s[i]

            if k < n and TJ[k] >= time[i] and TJ[k] <= time[i+1]:
                z = normal(loc=m, scale=np.sqrt(sigma))
                s[i+1] += s[i] * z
                k += 1

        fund = np.log(s[::252])  # yearly log fund values
        rate = r[::252]

        if len(fund) <= T1:
            continue

        E_T = max(min(np.exp(alpha * fund[T1]), np.exp(0.2 * T1)), np.exp(0.03 * T1))

        if j >= 50:
            E.append(E_T)
            R.append(np.exp(-rate[T1] * T1))

    return [np.mean(E), np.mean(R)]

# Load your mortality CSV - adjust path as needed for Colab
mortality_df = pd.read_csv("/content/china_mortality_2010_13.csv")  # update to your filename
qx = mortality_df.iloc[:, 1].values
px = mortality_df.iloc[:, 2].values

def Ppp(alpha, maturity=5, age=50):
    x = age
    tpx = np.cumprod(px[x:110])
    time_range = np.arange(0, maturity + 1)

    res = CPP_t(1, alpha)
    P_pp = res[0] * res[1] * qx[x]

    for t in time_range[2:]:
        res = CPP_t(t, alpha)
        P_pp += res[0] * res[1] * qx[x + t] * tpx[t - 1]

    res_T = CPP_t(maturity, alpha)
    final_val = P_pp + res_T[0] * res_T[1] * tpx[maturity - 1] - 1
    return final_val

sol = root_scalar(Ppp, args=(5, 50), bracket=[0, 1], method='brentq')
alpha_star = sol.root
print(f"Optimal alpha: {alpha_star}")

alphas = [alpha_star + x for x in np.arange(-0.05, 0.06, 0.01)]
ppp_results = [(a, Ppp(a)) for a in alphas]

for a, val in ppp_results:
    print(f"alpha = {a:.2f}, Ppp(alpha) = {val:.4f}")
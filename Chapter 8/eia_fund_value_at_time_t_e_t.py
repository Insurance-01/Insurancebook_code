# -*- coding: utf-8 -*-
"""EIA_fund value_at time t_E_T.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KCxyWZ8oSJfJ0-0GsxpOTV_tjg3EA0CG
"""

import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt

# Parameters
alpha = 0.7
lambda_inf = 0
lambda0 = 0.5
theta = 0.001
delta = 2

sigma1 = 0.2  # volatility of S
m = 0.05      # mean of Z
sigma = 0.03 ** 2  # variance of Z
rho = 0.1
S0 = 1

# r(t) parameters
a = 0.85837
b = 0.089102
sigma2 = 0.05
r0 = 0.05

gamma = 0.3
g = 0.03

# Time horizon
T = 1
t = 1
simulations = 3000
E = np.zeros(simulations)

def simulate_hawkes(lambda0, theta, delta, T):
    t = 0
    times = []
    intensity = lambda0
    while t < T:
        u = np.random.uniform()
        w = -np.log(u) / intensity
        t += w
        if t >= T:
            break
        d = np.random.uniform()
        current_lambda = lambda0 + np.sum(theta * np.exp(-delta * (t - np.array(times))))
        if d <= current_lambda / intensity:
            times.append(t)
            intensity = current_lambda + theta
        else:
            intensity = current_lambda
    return times

def M1(u):
    return 1 - np.exp(-a * (t - u))

def M2(u):
    return (1 - np.exp(-a * (t - u))) ** 2

integral_M1 = t - (1 - np.exp(-a * t)) / a
integral_M2 = t + (1 - np.exp(-2 * a * t)) / (2 * a) - 2 * (1 - np.exp(-a * t)) / a

for j in range(simulations):
    TJ = simulate_hawkes(lambda0, theta, delta, t)
    n = len(TJ)

    integral_lambda = lambda0 * (1 - np.exp(-delta * t)) / delta + \
                      lambda_inf * (1 - t * delta - np.exp(-delta * t)) / delta
    if n != 0:
        for tj in TJ:
            integral_lambda += theta * (1 - np.exp(-delta * (t - tj))) / delta

    lambda_big = b * t + (r0 - b) * M1(0) / a \
                 - sigma1 * sigma2 * rho * integral_M1 / a \
                 - sigma2 ** 2 * integral_M2 / a ** 2 \
                 - sigma1 ** 2 * t / 2 \
                 - integral_lambda * m

    M_T_r = np.log(S0) + lambda_big
    if n != 0:
        M_T_r += m * n

    V_T_r = sigma1 ** 2 * T + (sigma2 ** 2 / a ** 2) * integral_M2 + \
            2 * rho * sigma1 * sigma2 / a * integral_M1
    if n != 0:
        V_T_r += sigma * n  # NOTE: sigma is variance here, not std deviation

    sqrt_V = np.sqrt(V_T_r)
    a1 = norm.cdf((g * t / alpha - M_T_r + np.log(S0)) / sqrt_V)
    a2 = norm.cdf((gamma * t / alpha - M_T_r + np.log(S0) - alpha * V_T_r) / sqrt_V)
    a3 = norm.cdf((g * t / alpha - M_T_r + np.log(S0) - alpha * V_T_r) / sqrt_V)
    a4 = norm.cdf(-(gamma * t / alpha - M_T_r + np.log(S0)) / sqrt_V)

    E_T = np.exp(g * t) * a1 + \
          np.exp(alpha * M_T_r + alpha ** 2 * V_T_r / 2 - alpha * np.log(S0)) * (a2 - a3) + \
          np.exp(gamma * t) * a4
    E[j] = E_T

print("Expected Value (Mean E_T):", np.mean(E))

# Optional: plot distribution of E_T
plt.hist(E, bins=50, density=True, alpha=0.7)
plt.title("Distribution of Simulated E_T")
plt.xlabel("E_T")
plt.ylabel("Density")
plt.grid(True)
plt.show()
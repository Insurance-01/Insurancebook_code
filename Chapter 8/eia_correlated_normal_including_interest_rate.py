# -*- coding: utf-8 -*-
"""EIA_correlated_normal_including_interest_rate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BdsW6sCaSwEMtT1Wj4gG1MRHprcIeD-o
"""

# Import required libraries
import numpy as np
from scipy.stats import multivariate_normal
import matplotlib.pyplot as plt

# Set random seed for reproducibility
np.random.seed(42)

# Hawkes process parameters
lambda_inf = 0
lambda0 = 0.9
theta = 0
delta = 1.2195

# S_t parameters
sigma1 = 0.2  # 20% volatility
m_z = 0.05    # expectation of Z
sigma_z = 0.03**2  # variance of Z
rho = 0.1
S0 = 1

# r_t parameters
a = 0.85837
b = 0.089102
sigma2 = 0.03  # sigma_r
r0 = 0.05

# Design rates
gamma = 0.2
g = 0.03  # guaranteed minimum < gamma
T = 3
n_sim = 10  # number of simulations
dt = 1/262
m = int(T/dt) + 1

print("Parameters set. Time steps:", m)

# Covariance matrix for correlated Brownian motions
Sigma = np.array([[np.sqrt(dt), rho], [rho, np.sqrt(dt)]])

# Initialize S_t and r_t arrays
St = np.zeros((1, m))
rt = np.zeros((1, m))
St[0, 0] = S0
rt[0, 0] = r0

print("Covariance matrix Sigma:")
print(Sigma)
print("Initial St and rt values:")
print(St[:, :5])
print(rt[:, :5])

# Hawkes process simulation (Ogata's thinning algorithm)
def simulate_hawkes(lambda0, theta, delta, T):
    t = 0
    events = []
    while t < T:
        lambda_bar = lambda0 + theta * np.sum(np.exp(-delta * (t - np.array(events)))) if events else lambda0
        u = np.random.uniform()
        w = -np.log(u) / lambda_bar
        t = t + w
        if t >= T:
            break
        d = np.random.uniform()
        lambda_star = lambda0 + theta * np.sum(np.exp(-delta * (t - np.array(events)))) if events else lambda0
        if d <= lambda_star / lambda_bar:
            events.append(t)
    return np.array(events)

# Simulate Hawkes process
TJ = simulate_hawkes(lambda0, theta, delta, T)
n_jumps = len(TJ)

print("Number of jumps in Hawkes process:", n_jumps)
print("Jump times:", TJ)

# Visualize the jump times
plt.eventplot(TJ, orientation='horizontal', colors='black')
plt.title('Simulated Hawkes Process Event Times')
plt.xlabel('Time')
plt.yticks([])
plt.show()

# Time grid
t = np.linspace(0, T, m)

# Calculate the integral of the intensity function
integral_lambda = lambda0 * (1 - np.exp(-delta * t)) / delta + lambda_inf * (1 - t * delta - np.exp(-delta * t)) / delta

# Add jump contributions if any
if n_jumps != 0:
    for k in range(n_jumps):
        mask = t >= TJ[k]
        integral_lambda[mask] += theta * (1 - np.exp(-delta * (t[mask] - TJ[k]))) / delta

print("First 5 values of integral_lambda:", integral_lambda[:5])
print("Last 5 values of integral_lambda:", integral_lambda[-5:])

# Simulate r_t process (Euler-Maruyama)
for i in range(1, m):
    ex1 = multivariate_normal.rvs(mean=[0, 0], cov=Sigma)
    rt[0, i] = rt[0, i-1] + a * (b - rt[0, i-1]) * dt + sigma2 * np.sqrt(dt) * ex1[0]

# Plot the simulated interest rate path
plt.plot(t, rt[0])
plt.title('Simulated Interest Rate r_t')
plt.xlabel('Time')
plt.ylabel('r_t')
plt.show()

print("First 5 values of r_t:", rt[0, :5])
print("Last 5 values of r_t:", rt[0, -5:])
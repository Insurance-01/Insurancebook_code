# -*- coding: utf-8 -*-
"""EIA_hawkes_alpha_montecarlo_table.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OspqV94zvCll9p-WjVdj6EHlWS7tcjm6
"""

import numpy as np
import pandas as pd
from scipy.stats import multivariate_normal, lognorm
from scipy.optimize import root_scalar
from numpy.random import default_rng

rng = default_rng()

def simulate_hawkes(lambda0, theta, delta, T):
    s = []
    t = 0
    lambda_bar = lambda0
    while True:
        u = rng.uniform()
        w = -np.log(u) / lambda_bar
        t += w
        if t > T:
            break
        d = rng.uniform()
        intensity = lambda0 + np.sum(theta * np.exp(-delta * (t - np.array(s))))
        if d <= intensity / lambda_bar:
            s.append(t)
            lambda_bar = intensity + theta
        else:
            lambda_bar = intensity
    return np.array(s)

def eia_annual(age, maturity, sigma_r, sigma_s, rho1, mortality_file_path):
    T1 = maturity
    N = 15000
    gamma = 0.2
    g = 0.03
    lambda0 = 0.25
    theta = 1
    delta = 2
    sigma1 = sigma_s
    a = 0.85837
    b = 0.089102
    sigma2 = sigma_r
    rho = rho1
    m = 0.05
    sigma = 0.03
    dt = 1 / 252
    t1 = int(T1 / dt)

    r = np.zeros((N, t1 + 1))
    s = np.zeros((N, t1 + 1))
    r[:, 0] = 0.05
    s[:, 0] = 1

    for j in range(N):
        time_grid = np.cumsum(np.insert(np.full(t1, dt), 0, 0))
        TJ = simulate_hawkes(lambda0, theta, delta, T1)
        n = len(TJ)
        k = 0
        l = np.zeros(t1 + 1)
        l[0] = lambda0

        for i in range(t1):
            cov_matrix = np.array([[1, rho], [rho, 1]])
            ex = rng.multivariate_normal([0, 0], cov_matrix)

            r[j, i + 1] = r[j, i] + a * (b - r[j, i]) * dt + sigma2 * np.sqrt(dt) * ex[0]
            l[i + 1] = l[i] + (-delta * (lambda0 - l[i])) * dt
            s[j, i + 1] = s[j, i] + s[j, i] * (r[j, i] * dt + sigma1 * np.sqrt(dt) * ex[1] - l[i] * dt * m)

            if k < n and TJ[k] >= time_grid[i] and TJ[k] <= time_grid[i + 1]:
                l[i + 1] += theta
                z = lognorm(s=sigma, scale=np.exp(m)).rvs() - 1
                s[j, i + 1] += s[j, i] * z
                k += 1

    fund = np.log(s[:, ::252])
    rate = r[:, ::252]

    def CPP_t(t, alpha):
        E, R = [], []
        for j in range(N // 3, N):
            payoff = np.exp(alpha * fund[j, t])
            E_T = max(min(payoff, np.exp(gamma * t)), np.exp(g * t))
            E.append(E_T)
            R.append(np.exp(-rate[j, t] * t))
        return np.mean(E), np.mean(R)

    prob = pd.read_csv(mortality_file_path)
    qx = prob.iloc[:, 1].values
    px = prob.iloc[:, 2].values
    x = age
    tpx = np.cumprod(px[x:110])

    def Ppp(alpha):
        time = np.arange(0, T1 + 1)
        P_pp = CPP_t(1, alpha)[0] * CPP_t(1, alpha)[1] * qx[x]
        for i in range(2, len(time)):
            P_pp += CPP_t(time[i], alpha)[0] * CPP_t(time[i], alpha)[1] * qx[x + time[i]] * tpx[time[i - 1]]
        P_pp += CPP_t(T1, alpha)[0] * CPP_t(T1, alpha)[1] * tpx[T1 - 1]
        return P_pp - 1

    sol = root_scalar(Ppp, bracket=[0, 2])
    return sol.root

mortality_file_path = '/content/china_mortality_2010_13.csv'  # Update path
alpha1 = eia_annual(50, 7, 0.05, 0.2, 0.1, mortality_file_path)
alpha2 = eia_annual(50, 7, 0.05, 0.3, 0.1, mortality_file_path)
print(alpha1, alpha2)

ages = [40, 50, 60]
maturities = [3, 5, 7]
sigma_rs = [0.05, 0.1, 0.15]
sigma_ss = [0.2, 0.3]
rhos = [0.1, 0.0, -0.1]

X = np.zeros((27, 6))

for i, rho in enumerate(rhos):
    for j, age in enumerate(ages):
        for k, mat in enumerate(maturities):
            for l, sig_r in enumerate(sigma_rs):
                for m, sig_s in enumerate(sigma_ss):
                    a = 9 * i + 3 * j + k
                    b = 3 * m + l
                    print(f"Running {a},{b}")
                    X[a, b] = eia_annual(age, mat, sig_r, sig_s, rho, mortality_file_path)

df = pd.DataFrame(X)
df.to_csv('EIA_alpha_montecarlo.csv', index=False)
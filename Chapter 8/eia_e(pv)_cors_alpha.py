# -*- coding: utf-8 -*-
"""EIA_E(PV)_cors_alpha.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rbH0J317SEFrprwPKk_7BSE1PUtB1soW
"""

import numpy as np
import pandas as pd
from scipy.stats import norm
from scipy.optimize import root_scalar
import matplotlib.pyplot as plt

# Parameters
age = 60
maturity = 7
sigma_r = 0.15
sigma_s = 0.3
rho1 = -0.1
lambda_inf = 0
lambda0 = 0.9
theta = 1
delta = 1.219
sigma1 = sigma_s
m = 0.05
sigma = 0.03 ** 2
rho = rho1
S0 = 1
a = 0.85837
b = 0.089102
sigma2 = sigma_r
r0 = 0.05
gamma = 0.2
g = 0.03

def simulate_hawkes(lambda0, theta, delta, T):
    # Ogata's thinning method for Hawkes process simulation
    t = 0
    times = []
    intensity = lambda0
    while t < T:
        u = np.random.uniform()
        w = -np.log(u) / intensity
        t += w
        if t >= T:
            break
        d = np.random.uniform()
        current_lambda = lambda0 + np.sum(theta * np.exp(-delta * (t - np.array(times))))
        if d <= current_lambda / intensity:
            times.append(t)
            intensity = current_lambda + theta
        else:
            intensity = current_lambda
    return times

def CPP_t(tm, alpha, simulations=500):
    t = tm
    def M1(u): return 1 - np.exp(-a * (t - u))
    def M2(u): return (1 - np.exp(-a * (t - u))) ** 2

    E = np.zeros(simulations)
    integral_M1 = t - (1 - np.exp(-a * t)) / a
    integral_M2 = t + (1 - np.exp(-2 * a * t)) / (2 * a) - 2 * (1 - np.exp(-a * t)) / a

    for j in range(simulations):
        TJ = simulate_hawkes(lambda0, theta, delta, t)
        n = len(TJ)

        integral_lambda = lambda0 * (1 - np.exp(-delta * t)) / delta + \
                          lambda_inf * (1 - t * delta - np.exp(-delta * t)) / delta

        if n != 0:
            for tj in TJ:
                integral_lambda += theta * (1 - np.exp(-delta * (t - tj))) / delta

        lambda_big = b * t + (r0 - b) * M1(0) / a \
            - sigma1 * sigma2 * rho * integral_M1 / a \
            - sigma2 ** 2 * integral_M2 / a ** 2 \
            - sigma1 ** 2 * t / 2 - integral_lambda * m

        M_T_r = np.log(S0) + lambda_big
        if n != 0:
            M_T_r += m * n

        V_T_r = sigma1 ** 2 * t + (sigma2 ** 2 / a ** 2) * integral_M2 + \
                2 * rho * sigma1 * sigma2 / a * integral_M1
        if n != 0:
            V_T_r += sigma * n

        a1 = norm.cdf((g * t / alpha - M_T_r + np.log(S0)) / np.sqrt(V_T_r))
        a2 = norm.cdf((gamma * t / alpha - M_T_r + np.log(S0) - alpha * V_T_r) / np.sqrt(V_T_r))
        a3 = norm.cdf((g * t / alpha - M_T_r + np.log(S0) - alpha * V_T_r) / np.sqrt(V_T_r))
        a4 = norm.cdf(-(gamma * t / alpha - M_T_r + np.log(S0)) / np.sqrt(V_T_r))

        E_T = np.exp(g * t) * a1 + \
              np.exp(alpha * M_T_r + alpha ** 2 * V_T_r / 2 - alpha * np.log(S0)) * (a2 - a3) + \
              np.exp(gamma * t) * a4
        E[j] = E_T

    X_T = np.exp(-b * t - (r0 - b) * M1(0) / a + sigma2 ** 2 * integral_M2 / (2 * a ** 2))
    return np.mean(E), X_T

# Upload the mortality file manually or mount Google Drive
mortality = pd.read_csv("/content/AUS_MORTALITY_2016_rates.csv")  # Adjust path as needed
qx = mortality.iloc[:, 1].values
px = mortality.iloc[:, 2].values
x = age
tpx = np.cumprod(px[x:110])

def Ppp(alpha):
    T = maturity
    time = np.arange(0, T + 1)
    cpp1, cpp2 = CPP_t(1, alpha)
    P_pp = cpp1 * cpp2 * qx[x]

    for i in range(2, len(time)):
        cpp1, cpp2 = CPP_t(time[i], alpha)
        P_pp += cpp1 * cpp2 * qx[x + time[i]] * tpx[time[i - 1]]

    cpp1, cpp2 = CPP_t(T, alpha)
    value = P_pp + cpp1 * cpp2 * tpx[T - 1] - 1
    return value

sol = root_scalar(Ppp, bracket=[0.01, 1], method='brentq')
value = sol.root
print("Optimal alpha:", value)

alpha_vals = np.arange(0.7, 0.99 + 0.01, 0.01)
X3 = np.zeros(len(alpha_vals))

for i, a in enumerate(alpha_vals):
    X3[i] = Ppp(a)

print(X3)

plt.plot(alpha_vals, X3)
plt.axhline(0, color='red', linestyle='--')
plt.xlabel("Alpha")
plt.ylabel("Ppp(alpha)")
plt.title("Ppp vs Alpha")
plt.grid(True)
plt.show()
# -*- coding: utf-8 -*-
"""EIA_lamba_constant.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w5QOwMhDYfW1UzdCfNQDnBgzQseM9a9L
"""

import numpy as np
import pandas as pd
from scipy.stats import norm
from scipy.optimize import root_scalar
import os

def simulate_hawkes(lambda0, alpha, beta, T):
    t = 0
    s = []
    lambda_t = lambda0
    while t < T:
        u = np.random.uniform()
        w = -np.log(u) / lambda_t
        t += w
        D = np.random.uniform()
        lambda_star = lambda0 + alpha * np.sum(np.exp(-beta * (t - np.array(s))))
        if D <= lambda_star / lambda_t:
            if t <= T:
                s.append(t)
            lambda_t = lambda_star
        else:
            lambda_t = lambda_star
    return np.array(s)

def eia_annual(age, maturity, sigma_r, sigma_s, rho1, mortality_csv_path):
    lambda_inf = 0
    lambda0 = 0.9
    theta = 1
    delta = 1.2195
    sigma1 = sigma_s
    m = 0.05
    sigma_jump = 0.03 ** 2
    rho = rho1
    S0 = 1
    a = 0.85837
    b = 0.089102
    sigma2 = sigma_r
    r0 = 0.05
    gamma = 0.2
    g = 0.03
    T = maturity

    # Read mortality data
    prob = pd.read_csv(mortality_csv_path)
    qx = prob.iloc[:, 1].values
    px = prob.iloc[:, 2].values
    x = age
    tpx = np.cumprod(px[x:110])

    def CPP_t(tm, alpha):
        t = tm
        def M1(u): return 1 - np.exp(-a * (t - u))
        def M2(u): return (1 - np.exp(-a * (t - u))) ** 2

        simulations = 10000
        E = np.zeros(simulations)
        integral_M1 = t - (1 - np.exp(-a * t)) / a
        integral_M2 = t + (1 - np.exp(-2 * a * t)) / (2 * a) - 2 * (1 - np.exp(-a * t)) / a

        for j in range(simulations):
            TJ = simulate_hawkes(lambda0, theta, delta, t)
            n = len(TJ)

            integral_lambda = lambda0 * (1 - np.exp(-delta * t)) / delta + lambda_inf * (1 - t * delta - np.exp(-delta * t)) / delta
            if n != 0:
                for tj in TJ:
                    integral_lambda += theta * (1 - np.exp(-delta * (t - tj))) / delta

            lambda_big = b * t + (r0 - b) * M1(0) / a - sigma1 * sigma2 * rho * integral_M1 / a \
                         - sigma2 ** 2 * integral_M2 / a ** 2 - sigma1 ** 2 * t / 2 - integral_lambda * m
            M_T_r = np.log(S0) + lambda_big
            if n != 0:
                M_T_r += m * n

            V_T_r = sigma1 ** 2 * T + (sigma2 ** 2 / a ** 2) * integral_M2 + (2 * rho * sigma1 * sigma2 / a) * integral_M1
            if n != 0:
                V_T_r += sigma_jump * n

            a1 = norm.cdf((g * t / alpha - M_T_r + np.log(S0)) / np.sqrt(V_T_r))
            a2 = norm.cdf((gamma * t / alpha - M_T_r + np.log(S0) - alpha * V_T_r) / np.sqrt(V_T_r))
            a3 = norm.cdf((g * t / alpha - M_T_r + np.log(S0) - alpha * V_T_r) / np.sqrt(V_T_r))
            a4 = norm.cdf(-(gamma * t / alpha - M_T_r + np.log(S0)) / np.sqrt(V_T_r))

            E_T = np.exp(g * t) * a1 + np.exp(alpha * M_T_r + alpha ** 2 * V_T_r / 2 - alpha * np.log(S0)) * (a2 - a3) + np.exp(gamma * t) * a4
            E[j] = E_T

        X_T = np.exp(-b * t - (r0 - b) * M1(0) / a + sigma2 ** 2 * integral_M2 / (2 * a ** 2))
        return np.mean(E), X_T

    def Ppp(alpha):
        P_pp = 0
        for ti in range(1, T + 1):
            E, X = CPP_t(ti, alpha)
            if ti == 1:
                P_pp += E * X * qx[x]
            elif (x + ti) < len(qx) and (ti - 1) < len(tpx):
                P_pp += E * X * qx[x + ti] * tpx[ti - 1]
        E_T, X_T = CPP_t(T, alpha)
        return P_pp + E_T * X_T * tpx[T - 1] - 1

    sol = root_scalar(Ppp, bracket=[0.01, 1.0], method='brentq')
    return sol.root

age_vec = [40, 50, 60]
maturity_vec = [3, 5, 7]
sigma_r_vec = [0.05, 0.1, 0.15]
sigma_s_vec = [0.2, 0.3]
rho_vec = [0.1, 0, -0.1]

X = np.zeros((27, 6))
mortality_csv_path = "/content/AUS_MORTALITY_2016_rates.csv"  # âœ… Upload this file to Colab first!

for i, rho in enumerate(rho_vec):
    for j, age in enumerate(age_vec):
        for k, mat in enumerate(maturity_vec):
            for l, sigma_r in enumerate(sigma_r_vec):
                for m, sigma_s in enumerate(sigma_s_vec):
                    a = 9 * i + 3 * j + k
                    b = 3 * (m) + l
                    print(f"Calculating for age={age}, maturity={mat}, sigma_r={sigma_r}, sigma_s={sigma_s}, rho={rho}")
                    X[a, b] = eia_annual(age, mat, sigma_r, sigma_s, rho, mortality_csv_path)

np.savetxt("/content/EIA_lambda_constant.csv", X, delimiter=",", fmt="%.6f")
print("Results saved to EIA_lambda_constant.csv")
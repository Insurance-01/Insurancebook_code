# -*- coding: utf-8 -*-
"""EIA_jumpdiffusion_montecarlo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LrFEZ0suZIwnGqNZGYcCOewgqrMfOFGU
"""

import numpy as np
import pandas as pd
from scipy.optimize import root_scalar
from scipy.stats import multivariate_normal, norm

# Constants
N = 18000
T1 = 5
gamma = 0.2
g = 0.03
lambda0 = 0.5
theta = 0.01
delta = 5
sigma1 = 0.2
a = 0.85837
b = 0.089102
sigma2 = 0.05
rho = 0.1
m = 0.05
sigma = 0.03**2
dt = 1 / 252
t1 = int(T1 / dt)

# Empty arrays for r and s
r = np.zeros((N, t1 + 1))
s = np.zeros((N, t1 + 1))
r[:, 0] = 0.05
s[:, 0] = 1

# Poisson jump simulation
def npois(lam, T):
    times = np.cumsum(np.random.exponential(scale=1/lam, size=1000))
    jump_times = times[times <= T]
    return jump_times

# Simulate r_t and s_t
for j in range(N):
    times = np.concatenate([[0], np.full(t1, dt)])
    time = np.cumsum(times)
    TJ = npois(lambda0, T1)
    n = len(TJ)
    k = 0
    l = np.full(t1 + 1, lambda0)

    for i in range(t1):
        Sigma = np.array([[1, rho], [rho, 1]])
        ex = multivariate_normal.rvs(mean=[0, 0], cov=Sigma)

        # Vasicek r_t
        r[j, i+1] = r[j, i] + a * (b - r[j, i]) * dt + sigma2 * np.sqrt(dt) * ex[0]

        # s_t
        s[j, i+1] = s[j, i] * (r[j, i] * dt + sigma1 * np.sqrt(dt) * ex[1] - l[i] * dt * m) + s[j, i]

        if k < n and TJ[k] >= time[i] and TJ[k] <= time[i+1]:
            z = norm.rvs(loc=m, scale=np.sqrt(sigma))
            s[j, i+1] += s[j, i] * z
            k += 1

# Extract annual values
fund = np.log(s[:, ::252])  # log yearly values
rate = r[:, ::252]

def CPP_t(t, alpha):
    idx = int(t)
    R = np.zeros(N - N // 3)
    E = np.zeros(N - N // 3)

    for j in range(N // 3, N):
        E_T = max(min(np.exp(alpha * fund[j, idx]), np.exp(gamma * t)), np.exp(g * t))
        E[j - N // 3] = E_T
        R[j - N // 3] = np.exp(-rate[j, idx] * t)

    return [np.mean(E), np.mean(R)]

# Replace this with the actual mortality CSV path
prob = pd.read_csv("china_mortality_2010_13.csv")
qx = prob.iloc[:, 1].to_numpy()
px = prob.iloc[:, 2].to_numpy()

age = 50
x = age
tpx = np.cumprod(px[x+1:110])

def Ppp(alpha):
    time = np.arange(0, T1 + 1)
    cpp1 = CPP_t(1, alpha)
    P_pp = cpp1[0] * cpp1[1] * qx[x + 1]

    for i in range(2, len(time)):
        cppt = CPP_t(time[i], alpha)
        P_pp += cppt[0] * cppt[1] * qx[x + time[i]] * tpx[time[i - 1]]

    cppt_final = CPP_t(T1, alpha)
    value = P_pp + cppt_final[0] * cppt_final[1] * tpx[T1 - 1] - 1
    return value

sol = root_scalar(Ppp, bracket=[0, 2], method='brentq')
value = sol.root
print("Optimal alpha:", value)

al = [(value - 0.04), (value - 0.03), (value - 0.02), (value - 0.01),
      (value + 0.01), (value + 0.02), (value + 0.03), (value + 0.04)]

print("Ppp(value - 0.4):", Ppp(value - 0.4))
for i, a in enumerate(al):
    print(f"Ppp(alpha={a:.4f}) =", Ppp(a))